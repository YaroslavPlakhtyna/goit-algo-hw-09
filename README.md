# Аналіз жадібного алгоритму та динамічного програмування для задачі підрахунку найменшої кількості монет у решті

Цей аналіз порівнює ефективність жадібного алгоритму та підходу динамічного програмування (з кешуванням до максимального номіналу) для обчислення мінімальної кількості монет, необхідних для решти. Порівняння базується на часі їх виконання для різних сум, різної кількості спроб та однакового набору номіналів монет (1, 2, 5, 10, 50), висвітлюючи їхню продуктивність та ефективність при обробці великих обсягів даних.

## Огляд алгоритмів

### Жадібний алгоритм
- **Переваги**: Простий у реалізації та розумінні. Може бути високоефективним для певних наборів номіналів монет, де він швидко знаходить оптимальне рішення.
- **Недоліки**: Його ефективність та точність значно падають для складних наборів номіналів або більших сум, з огляду на його лінійну природу.

### Динамічний флгоритм з кешуванням сум до максимального номіналу
- **Переваги**: Забезпечує оптимальне рішення для будь-якого набору номіналів монет та будь-якої суми завдяки його вичерпному підходу, що розглядає всі можливості.
- **Недоліки**: Більш складний для реалізації. Вимагає більше обчислювальних ресурсів (пам'яті) порівняно з жадібним алгоритмом, особливо для менших сум.

## Порівняння продуктивності

| Діапазон суми | Кількість сум  | Жадібний алгоритм (секунди) | Динамічний алгоритм з кешуванням до максимального номіналу (секунди) |
|---------------|----------------|-----------------------------|----------------------------------------------------------------------|
| 100           | 1000           | 0.0174641                   | 0.0019595                                                            |
| 100           | 10000          | 0.1857726                   | 0.0474926                                                            |
| 100           | 100000         | 2.3911602                   | 0.4588581                                                            |
| 1000          | 1000           | 0.1578522                   | 0.0032317                                                            |
| 1000          | 10000          | 0.4512948                   | 0.0731478                                                            |
| 1000          | 100000         | 3.4264551                   | 0.5466452                                                            |
| 10000         | 1000           | 0.4743464                   | 0.0109842                                                            |
| 10000         | 10000          | 2.5351470                   | 0.0409513                                                            |
| 10000         | 100000         | 26.681583                   | 0.3242700                                                            |

З огляду на отримані результати, при великих сумах продуктивність жадібного алгоритму значно погіршується, показуючи суттєве збільшення часу виконання. Це погіршення є результатом його лінійного підходу, який стає значно менш ефективним зі збільшенням суми та їх кількості.

Навпаки, підхід динамічного програмування, незважаючи на незначне збільшення часу виконання зі збільшенням сум і спроб є більш масштабованим. Його механізми попередніх обчислень та кешування допомагають зменшити вплив великих сум на продуктивність, роблячи його більш ефективним для даного роду задач.

## Висновок

Підхід динамічного програмування є більш ефективним для задачі решти монет, особливо при роботі з великими сумами. Його здатність гарантувати оптимальне рішення та обробляти складні набори номіналів робить його більш переважним для сценаріїв, які вимагають високої точності та ефективності.

Проте, для простіших проблем або коли обчислювальні ресурси обмежені, жадібний алгоритм все ще може бути життєздатним варіантом, пропонуючи швидші рішення з меншими просторовими витратами, за умови, що його обмеження прийнятні для конкретного завдання.
